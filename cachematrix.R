## Put comments here that give an overall description of what your
## functions do

## Creates a list (but think object) that knows how to deal with a matrix and its
## cached inversed value
##
## Parameters:
## - x, matrix that is always assumed to be invertible
##
## Maps internal variable m to store the value of the inversed matrix
## Defines set() to map 'x' to the value of original matrix
## Defines get() to return the eventually defined value of original matrix in 'x', it also 
##  overrides/resets any previosuly defined value of 'm' (aka cached matrix)
## Defines setSolve() to store the inversed matrix ("solveParam") in 'm'
## Defines getSolve() to return the stored 'm' value (aka cached matrix)
## Returns a list (think object) on which we can invoke these defined operations 
makeCacheMatrix <- function(x = matrix()) {
        m <- NULL
        set <- function(y){
                x <<- y
                m <<- NULL
        }
        
        get <- function() x
        setSolve <- function(solveParam) m <<- solveParam
        getSolve <- function() m
        list(set = set, get = get, 
             setSolve = setSolve,
             getSolve = getSolve)
}


## Calculates the inverse of a matrix or uses a cached copy, if exists. Stores the cached
## calculated value if not previously done.
##
## Parameters:
## x, a cacheMatrix previously generated by makeCacheMatrix()
##
## First tries to see if the x alreaady contains a cached matrix, if so, returns it
## Else, it will obtain the original matrix value stored in x and calculate its
## inverse using solve(), then stores that result invoking x.setSolve() and 
## then returns the calculated inversed value
cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
        m <- x$getSolve()
        if (!is.null(m)){
                message("getting *CACHED* inversed matrix")
                return(m)
        }
        
        # no return executed so we calculate (solve) the inverse and cache it for next time        
        data <- x$get()
        m <- solve(data, ...)
        x$setSolve(m)
        m
}

## "Unit Test". This automates what would otherwise be manual testing
## To test and see outputs 
## > source("cacheMatrix.R"); 
## > r = testCacheSolve()
## > r$original
## > r$expected
## > r$tested
testCacheSolve = function(){
      originalMatrix = matrix(data=c(4,3,3,2), nrow=2)
      expectedMatrix = solve(originalMatrix)
      cachedMatrix = makeCacheMatrix(originalMatrix)
      testMatrix = cacheSolve(cachedMatrix)
      
      #assert the cachedSolve is consistent
      if ( identical(expectedMatrix, testMatrix)){
              message("Cached Value MATCHES")
      }else{
              message("No match :(")
      }
      
      list(original = originalMatrix, expected = expectedMatrix, tested = testMatrix)
}




